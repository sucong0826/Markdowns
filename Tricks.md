# Java Tricks 有意思的欺骗系列（一）- 内部类：背后耍花样 #

### 写在最开始 ###
------
其实今天挺累，运动了一大波，回到公司继续干活，夜已至深，深感精神疲惫，在椅子上转了几圈，突然想到一个事情，前几天因为自己的一片不成气候的文章《Final of Java，这一篇差不多了》有幸和自己的老大做了一番深入的讨论，从最开始的final到最后谈天说地，也都是技术上比较有趣的事情，比如CPU处理器的乱序执行啊，Java的一些小tricks啊，听得我津津乐道。

有一个想法油然而生，Java这门语言或者其它编程语言并没有我们想象的那么乖，我们写什么他们就做什么。所以，关于我们讨论的一些Java中的小骗局或者小tricks，我就想把它整理出来，供大家茶余饭后看看，吐吐槽，乐呵乐呵，就当是枯燥的编程生活中的一些自我取乐吧！哈哈。

最后，我仅代表我个人声明，写的好或不好，希望大家把你们知道更多的编程趣事分享分享，那些幕后黑手或者意象不到的内容，大家都多多分享上来，我帮你们做整理或者做链接，引入到大家的blog中，相互学习，相互扯蛋。 文章尽量短小，说明问题，浅入原理即可。如果内容您知道，就当批评讨论，如果您不知道，对这份内容要保持怀疑，因为它不一定是对的，自己深入钻研，返回指正，这是我希望看到的。

好了，不废话，今天我先来开个头，简单说说Java中内部类的骗局吧，同时Android的BestPractice也给出了相关内容，我们一起来看看。

### 正文 ###
------
问题是这样产生的，熟悉Java或者Java的大神们，对**内部类（InnerClass）**肯定有很多很深入的了解，但是我能说的是，其实内部类算是一个小“骗子”。

为什么说它是骗子？ 别急，先上代码！

	public class OuterClass {
		
		// words for what you said.
		private String words;
		
		// method say belongs to OuterClass
		private void say(String words) {
			System.out.println("What I said is " + words + "!");
		}

		// defines an inner class
		private class InnerClass {
			void printOut() {
				say(words);
			}
		}
	}

代码写的很一般，大家就将就着看，也没什么实际工程上的含义，毕竟文章就是大家乐呵的，那么就不用太讲究了反而晦涩难懂就不好了。
以上这段代码呢，超级简单，有点Java基础的同学就可以读懂的。

哈哈，相信大家接触Java的时候，一定从老师或者朋友或者其从他地方得知到一条消息，一个Java文件中只能有一个类，这是Java这门语言的一个基础规定，但是我这句话一定会说“你说错了”。没错，因为这句话有漏洞，就是一个Java文件中只能存在一个修饰为public的类。好，话到这里就够了，再说就远了。但Java中还有一种类就是内部类，那什么是内部类？我就简单的说，内部类就是定在一个类中的类，简明说“**类中有类**”。

就如我们上面提供的代码一样，在`OutClass`中定义了一个`InnerClass`，这就是一个内部类。我稍微回退一下，为什么我在上一段介绍那么基础的内容，一个Java文件中只能存在一个修饰为public的类，其实在我理解是有点意思的。我们先不考虑Java的体系结构，既然规范定义了，那我们总不能违法吧，也总不会这么定义吧，这在一个Java文件中是不允许的。  
	
	public class OuterClassA {
	}
	
	public class OuterClassB {
	}

（以下为我的YY，为什么设计内部类是有合理的介绍和说明的！）但Java的设计者认为，总不能一个类一直写到底，规定让写两个同时在一层，那我们就嵌入一个到另一个吧！  
以上内容纯属我瞎扯的，为什么要设计出Java的内部类，我这里给出几个简答的说明：  

- 内部类也是类，但它可以在某些情况下隐身起来。 即内部类同一个package中的其他类在某些场景下是隐藏的，如我们上文定义的InnerClass。  

- 内部类在我们需要利用回调的方式来处理业务逻辑的时候，是很便捷的，尤其是匿名内部类。 举个栗子，Android中的`button.setOnClickListener(new View.OnClickListener(){...})`是非常常见的做法。

- 内部类方法可以访问该类定义所在的作用域中的的数据，包括私有的哦。

话说，说到现在，我在啰嗦什么，我就在铺铺路，有意思的内容马上就来了。(●ˇ∀ˇ●)  
“你说我是骗子！拿出证据来！”，好，我们拿出证据。就执行我上面提供的代码。

我们将代码粘入一个文本中，并利用命令行编译了它，看图说话。  

![source code files](http://i.imgur.com/3oJpwjA.png)

图中红色部分圈住的是源文件，经过编译得到了三个文件，分别是
`OuterClass$1.class`,  
`OuterClss$InnerClass.class`,  
`OuterClass.class`。

首先最后两个我们好理解，一个源文件的字节码文件，一个是内部类产生的字节码文件，那么第一个是什么东西？我们逆向一下看看。通过javap的方式，现在将三个类的代码都反编译得到它们的真实面目。

![OuterClass$1.class](http://i.imgur.com/2Pld74o.png)  

![OuterClass$InnerClass.class](http://i.imgur.com/NYVX4sU.png)

![OuterClass.class](http://i.imgur.com/Mt1ZkUl.png)

OK! 三张证据截图均已上传，那么我们就来分析一下吧！到底编译器（或者说内部类）骗了我们什么！  
首先，OuterClass$1我们暂且先不用关心，就看后两个截图证据，就可以说明问题了。
我们在过一遍源代码，内部类InnerClass中有一个方法，`printOut`，方法内部调用了外部类中的`say`方法，执行一个打印动作。很简单的调用，我们来看从执行，到处理。

	public static void main(String[] args) {
        new OuterClass().new InnerClass().printOut();
    }

结果：在OuterClass中，我们写了主函数，是为了调试用，直接调用到了`printOut`方法。内容也顺利输出。

OuterClass.java被编译器编译通过并且执行，得到了字节码文件。所以，即使我们类嵌入在另一个类中作为内部类，对于编译器来说，它依然不买账，还是会把它们“拆散”，生成自己各自的字节码，只不过在文件名字和字节码内部，编译器做了自己的处理，骗局就在这里！

我们看截图，在OuterClass$InnerClass.class中，我们发现了如下内容:

![OuterClass$InnerClass.class impl](http://i.imgur.com/dT3wH1S.png)  

我们在InnerClass中确实调用了外部类OuterClass的方法`say(String)`,但是奇怪的是，现在红色圈住的部分，就是printOut的内部执行代码，`this.this$0`这是持有外部类的一个引用，通过构造器传入的，这个好理解，但是`OuterClass.access$000(this.this$0, OuterClass.access$000(this.this$0));`就不对了！！ 就是靠猜，我们也知道这是在执行OuterClass中的`say`方法啊，可是，我们的say方法在源码中定义的明明是private修饰的，根据Java的访问权限控制，private在类内才能访问。那么，这么一来，Java在自相矛盾啊！

读到这里，不知道大家懵了还是懂了！反正第一次我研究的时候，就是MB了。**那么，就是编译器让内部类做了什么，骗了我们！**

### 解密 ###
------
其实编译器（内部类）也不算是骗，它也是处心积虑，一片好心，但是做了一堆事情也没说。所以我说骗有点严重了，所以加上双引号替它平反一下。

好，我们开始解密，其实我说白了就很容易理解了，大家看看逆向得到的内容就明白了。OuterClass中的`access$100`方法升级了。什么？升级了？！
没错，大家仔细看看，**它的private修饰符不见了。由private提升到了package的访问权限。这就是背后内幕。**

	static void access$100(OuterClass, java.lang.String);
对，编译器偷偷的在我们不知道的情况下，偷偷地将我们定义的private函数升级为包内访问的函数，这就是编译器背着我们做的事情。与其说骗，不如说它用心良苦吧。

那编译器为什么要这么做！？道理很简单，为了圆场咯。正如我们上面提到的，Java语言规定了一个文件中只可以有一个public修饰的类，但是为了以上3条宗旨，Java设计了内部类，内部类也是类，所以在编译的时候，我们依然看到了3个字节码文件，而不是一个。那既然是3个字节码文件，独立开的那怎么体现内部类的优势特点呢，没办法，自己做的设计自己来想办法，那就把方法访问升级了吧，反正内部类编译后和外部类一定是在同一个包下的，那就变成包内访问吧，问题就这么愉快而偷偷的解决了，内部类通过外部类实例传递进来，私有的方法也提升了等级，这样就可以了。**（注意：一定要注意，我们强调的private的方法，如果是其他级别的访问权限，编译器就没有必要背着我们做这些事情了。）**

### 写在最后 ###
------
解密的部分很短小，希望我能说清楚又不想通篇大论，点到为止，至于内部类更加深入的部分，我也不想在这里讨论，这是一个像生活片段一样的内容，大家看看了解了解就OK了，如果真想弄得深入彻底，就自行学习了。

如我最开篇写的一样，我依然希望认真看的朋友同学来吐槽和交流，同时把你们遇到有意思的tricks拿出来大家分享一下，我来做整理，这都没问题。

感谢顾岩（我的老大）给我讲了很多，跟他讨论的时候我非常高兴并且感受到技术带给我的快乐和憧憬，这里我致谢！这个文章我会一直整理下去，有意思的我就拿出来，写一写，整理整理，交流交流，程序员嘛，除了写代码之外，这是也一大乐趣吧！

最后，希望Android开发的伙伴们可以看看Google官方提供的BestPractice，从这它我也学到不少东西。附上链接。  
[Consider Package Instead of Private Access with Private Inner Classes](https://developer.android.com/training/articles/perf-tips.html "Consider Package Instead of Private Access with Private Inner Classes")

好了！夜已经深了！收拾收拾回家了，明天还要修复bug。 再续！