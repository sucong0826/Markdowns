# What is Closure ?

## 简介
在编程语言中，闭包（Closure），也是词法闭包或者函数闭包，是用于在把**函数作为第一等级**的语言中实现词法范围的**名称绑定**的技术。操作上，一个闭包是一种**记录**，这个记录存储了**函数与环境**。所提及的**环境**：是一种**映射**，这样的映射关系关联了每一个函数的自由变量（变量在本地被使用，但是定义在一个封闭范围中）和创建闭包时绑定名称的值或者引用。一个闭包，不像一个普通的函数，它（闭包）允许函数去访问那些被捕获的变量（captured variables），通过闭包复制的变量的值或者引用，甚至当在函数之外的范围被调用。

例如，如下的程序代码段定义了一个高阶函数（**一个高阶函数需要一个或者多个函数作为参数，然后返回一个函数作为结果，其他所有的函数就都是一阶函数**），高阶函数为`startAt`，有一个参数是`x`，它内部有一个嵌套函数`incrementBy`，嵌套函数`incrementBy`有对`x`的访问权限，因为`incrementBy`是在`x`的词法作用范围之内，即使`x`并不是`incrementBy`的本地变量。函数`startAt`返回了一个闭包，这个闭包从对`startAt`的调用中得到包括了x值的拷贝，或者x引用的拷贝，而`incrementBy`函数完成了`x`和`y`的加法计算。

```JavaScript
function startAt(x)
  function incrementBy(y)
    return x + y
   return incrementBy
   
variable closure1 = startAt(1)
variable closure2 = startAt(5)
```

注意，作为`startAt`返回的一个函数，变量`closure1`和`closure2`是函数类型。虽然`closure1`和`closure2`参照了同一个函数`incrementBy`，但是所关联的环境是不同的，而且在两个不同的调用中，因此这个闭包将会用不同的值绑定`x`的名字到两个不同的变量上，从而将函数评估为不同的结果。

## 历史和词源
闭包的概念是在1960年为了lambda计算的机械评估而发展出来的，在1970年在PAL语言中国年首次被完全实现的。

## 匿名函数
闭包的术语通常被误解地来表示**匿名函数**的概念。这很有可能是因为很多程序员同时学习到了这两种概念，或认为以一些小的帮助函数形式出现（helper）的就是匿名闭包。一个匿名函数是一个**没有名字的函数的字面表示形式**，而闭包是一个**函数的实例，一个非本地变量已经被绑定到值，又被绑定到存储空间的值**。

一个匿名函数（函数字面表达，lambda抽象）是一个函数定义，这匿名数没有绑定到一个修饰符上（identifier）。

匿名函数通常：  
1. 作为参数被传递到高阶函数中
2. 用来构建需要返回函数的高阶函数的的返回结果

如果一个函数只使用一次或者几次，一个匿名函数可能比使用一个命名的函数更加轻量，更加方便。匿名函数在一些函数式的编程语言和以函数为第一等级的语言中随处可见。

匿名函数是**嵌套函数的一种形**式，它允许访问那些包含这个匿名函数中的非本地变量。这意味着**匿名函数需要使用闭包来实现**。不像有名字的内嵌函数，如果不在**fixpoint operator**或者将他们绑定到一个名字上的话，是无法实现递归的。

```Python
def f(x):
  def g(y):
    return x + y
  return g
  
def h(x):
  return lambda y : x + y 

>>> a = f(1)
>>> b = f(1)
>>> h(1)(5)
>>> f(1)(5)
```
`a`和`b`都是闭包，或者，具有闭包值的变量，在这两种情况下都是通过从闭包函数返回带有自由变量的嵌套函数的参数x。然而，在第一种情况下，嵌套函数有名字，`g`函数，而第二种情况就是匿名的。闭包不需要被分配到变量上，可以被直接使用，这种用法可被认为是一个**匿名闭包**。

尤其注意，被嵌套函数的定义不是**它们自己的闭包（themselves closures）**，他们有自己还没被绑定的变量。只有使用参数的值评估封闭函数时，嵌套函数的自由变量才会被绑定，从而创建一个闭包，通过封闭函数返回这个闭包。

最后，一个闭包与一个函数的区别仅在于那些非本地变量超出了作用范围之外的自由变量（free variables），否则定义环境和执行环境就会一致了，而且没有办法去区分这些。例如，在如下的程序中，函数有一个自由变量`x`，在全局范围中没有绑定到任何非本地变量，这些函数在定义了`x`的相同的环境中执行，所以无论是否是闭包，它都是无形的。

```
x = 1
l = [1, 2, 3]

def f(x):
  return x + y
 
map(f, 1)
map(lambda y: x + y, 1)
```

```
x = 0·
def f(x):
  return x + y

def g(z):
  x = 1
  return f(z)
  
g(1)
```

## Applications
闭包的使用是**和语言关联**的，这些语言是把函数作为第一等级对象的，同时这些高阶函数会返回函数作为返回结果，或者作为参数被传递到其他的函数调用中。如果有自由变量的函数是第一等级的话，会返回一个创建的闭包。闭包例如在JavaScript中通常被用来处理回调（callbacks），尤其是事件处理（event handlers），闭包被用在动态网页的交互部分。传统的命令语言，如Algol， C，Pascal，是不支持嵌套函数的，或者不支持当外部封闭函数退出时调用内部嵌套函数的。因此避免在这些函数中使用闭包。

闭包通常用来实现**连续传递风格**，利用这种方式**隐藏状态**。如构建这样的对象或控制结构是可以使用闭包来实现的。在一些语言中，一个闭包可能会在一个函数定义在另一个函数中出现，而且内部函数引用了外部函数的本地变量。在运行时，当外部函数执行时，会形成一个闭包，是由外部函数的变量通过闭包组成了内部函数的代码和引用。

#### First-class functions
闭包在那些以函数为第一等级的值的方式出现在一些语言中，换句话说，一些语言允许函数以参数的形式传递，然后从函数调用返回，绑定变量的名字等。看如下的例子：
```Scheme
; Return a list of all books with at least THRESHOLD copies sold.
(define (best-selling-books threshold)
  (filter
    (lambda (book)
      (>= (book-sales book) threshold))
      book-list))
```
在这个例子中，lambda表达式出现在函数`best-selling-books threshold`之内，当lambda表达式被评估时，Scheme创建了一个闭包，这个闭包由lambda表达式和一个指向`threshold`变量的引用组成，这个变量在lambda表达式中是一个自由变量。

接下来，这个闭包被传递到一个`filter`函数中，这个函数将会重复地调用来决定哪些书籍应该被添加到结果列表，哪些应该被放弃掉。因为闭包本身有一个引用指向`threshold`，每次`filter`函数调用这个闭包的时候，就会闭包就可以使用这个变量。而这个`filter`函数本身可能被定义在一个完全独立的文件中。

这有一个用JavaScript写的相同的例子。
```JavaScript
// Return a function that approximates the derivative of f
// using an interval of dx, which should be appropriately small.
function derivative(f, dx) {
  return function (x) {
    return (f(x + dx) - f(x)) / dx;
  };
}
```
在没有闭包的语言中，一个自动的本地变量的生命周期与声明这个变量的栈桢的执行周期保持一致。在有闭包的语言中，只要引用指向这些变量，那么它们的存在时间就和闭包一样长。这和某些实现了垃圾回收的语言是大致相同的。

#### State Representation 状态表述
一个闭包可以关联一组函数的私有变量，这些变量会坚持到几组调用之后。这些变量的作用域仅仅包括了封闭函数的，所以它不能被其他程序代码访问。在一些状态型的语言中，闭包可以被用来实现状态表述和信息隐藏的范式，因为闭包的封闭变量是不定性拓展的，所以在一次调用中构建的值在下一次调用中是可用的。闭包以这样的方式使用就不在有参照透明度，而且不在是纯函数了，尽管如此，他们通常被使用在非纯函数语言中，例如Scheme。

## Other uses 其他使用
- 因为闭包是延迟评估的，即直到它们被调用之前，闭包是不会做任何事情的，闭包可以用来定义**控制结构（control structure）**。例如，所有的Smalltalk的标准控制框架，包括分支（if/then/else）和循环（while／for），都是使用那些接受闭包的对象来被定义的。用户可以轻松地定义他们的控制结构。
- 在那些实现分发的语言中，封闭了相同环境的多元函数可以被生成，使得它们可以通过选择环境来进行私有地沟通。在Scheme中：
```Scheme
(define foo #f)
(define bar #f)

(let ((secret-message "none"))
  (set! foo (lambda (msg) (set! secret-message msg)))
  (set! bar (lambda () secret-message)))
  
(display (bar)) : prints "none"
(newline)
(foo "meet me by the docks at midnight")
(display (bsr))
```