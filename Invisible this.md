### Java Tricks系列（二）看不见的this ###

### 写在最开始 ###
------
接到明天去出差的命令行之后，在我的大脑编译器中编译了一次，抛出了很多的警告。其中最让我忧伤的还是看书整理自己的文章，不过工作就是工作，要服从安排。所以冒着明天可能起不来的风险，赶紧多读了几页，这时候一个有趣的很小很小的点被我发现了，我也觉得还算有趣，便赶紧多了解了一些做了点验证，内容深入很浅，适合喝杯咖啡，吃吃早点的时候看看。文章的题目和内容很吻合，就是《看不见的this》，最近一直在看JVM，算是一边学习，一边记忆吧！ 进入正文...


### this在哪里？ ###
------
先用代码来说明情景吧。

	public class TestA {
	
	  	private int a;
	
	  	public static void testFor(int position) {
	
	  	}
	
	  	public void inject(String injection) {
	      this.a = 1;
	  	}
	}

和其他系列文章一样，代码还是很简单，没有实际工程的意义，就是拿来演示说明用的。  
首先我们定义了一个类：


1. `TestA`，这个类中有一个成员域`a`，`int`类型的，关于域我们就定义一个就可以说明问题了。
2. 接下来，类中定义了方法，一个是`testFor(Test)`，`static`修饰的与类相关的方法，与实例无关，对于这个方法我们只要知道这么一个信息就可以了。
3. `inject`方法，这个方法就是一个实例方法，至于参数，返回类型，访问权限我们暂时不关心，也不是重点，可以随意调整，对于这个方法，我们只要它是实例方法就可以了。

OK，TestA的相关信息我们都简单的介绍了一遍了，那么，我们回到这个问题上来，为什么说是**不可见的this呢**？原因还用从我看到的字节码文件说起。

其实，当我们的Java文件被编译器编译之后，得到了一个二进制流文件，就是一个class文件。这个class文件中都是紧凑的字节码数据，如CA FE BA BE，这也是有趣的魔数作为字节码文件的开始。那么每一个8位的字节代表一条指令，共计是0-255取值范围，共计可以代表256条对应的指令。那么其中就有方法的方法体（Code）被编译后的二进制数据存储在这个class文件中。

接着我们来简单的介绍一下Code的属性表，Code属性表其实作用很简单，就是用来记录一个方法的信息，那么它里面都有什么信息？我就列举出里面比较重要的说明即可。  

![Code属性表（部分）](http://i.imgur.com/SsGCO1l.png)
其中呢我就摘要了比较能说明问题的属性来说，这里一共列举了3个属性：  
1.`max_local`   
2.`code_length`  
3.`code`

其中，第一个属性值`max_local`是最能说明问题的，问题也是从这出来的，`max_local`的作用就如表里描述的一样，一个方法内的局部变量所需要的存储空间，单位呢就是`Slot`，如果大家对这里感兴趣可以看看JVM对应的部分。当我通过逆向(javap)来看`TestA`的字节码的，看到了如下的内容：  
![ClassFile_TestA](http://i.imgur.com/GMEURMd.png)  

正如我红色圈出来的部分就有有趣的事情发生了。  
首先，第一个有趣的事！我并没显示声明类的构造器，这个没问题，系统会帮我们补上默认的构造器，但是**默认的构造器是没有参数**的。但是第一个红色圈的地方却显示`locals = 1, args_size = 1`，而且Code中的第一条指令就是`0: aload_0`对应就得字节码`0x2a`。这让我不得其解。

然后，第二个有趣的事情：`testFor`方法，是`static`修饰的，我们传入了一个参数，那么它很正常，没有什么问题。但是inject方法就有趣了，我明明在入参列表声明了一个参数`String injection`这个参数，但是在第三个红色的圈中，得到了如下的信息，`locals = 2, args_size = 2`，明明声明了一个参数，为什么`locals, args_size`都是2呢？而且第一条指令也是`0: aload_0`。

为了解决我的疑惑，我去查询了`0: aload_0`，`0x2a`这条指令到底是什么意思？

> 将第一个引用类型的本地变量推送至栈顶。  
> From 《深入理解Java虚拟机》

有了这句话，我们能得到很多信息，首先它是第一条指令，肯定要将这个本地变量压入栈内，每一个方法的执行都会创建对应的StackFrame，那么执行压入操作没什么问题。 然后，“将第一个”，“引用类型”，这个两个关键词提醒了我，首先，引用类型？我并没有在方法中定义哪些引用类型的变量，唯一能想到的就是**“this”**，其实它就是**this**。好，虽然我们没看见this，但是呢！**this**已经悄悄地进入了我们类中实例方法中了。

### 问个为什么 ###
------
其实，这个为什么回答起来还是很简单的！ ^. ^  
原因就是编译器让类中的所有实例方法可以得到当前类的this引用，以便更好的访问类中其他的非静态域和实例方法。  

大家注意，我一直都在强调**实例方法**，没错，因为静态的方法与实例无关，自然也就不需要this，从图中我们也看到了，除了我们在参数列表中声明的`int`类型的参数之外，`locals, args_size`就是1，没有其他的了。

所以我们在写代码的时候，可能有时候会有意间无意间的写**this**，或者不写**this**，但是对于一个方法来说，只要是实例方法，在编译后的字节码中一定都会把**this**传入进来，无须通过方法的参数，而是直接将**this**作为第一个引用类型的本地变量推送至栈顶，这也就是：

**为什么我们明明没有传入this，但在实例方法的栈中，还有一个参数的原因，因为实例方法的心中一直留着它（this）的第一位置，真爱啊。**


### 写在最后 ###
------
相信这个小短文已经说明问题了，而且和标题说明的一样，《看不见的this》，也是从JVM来观察的，算是一边学习一边记录的方法吧，希望这篇文章可以读起来有趣，也期待有趣的反馈。

12：16分，赶紧滚回去睡觉了，明天还要起早出差去。