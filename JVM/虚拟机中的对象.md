在Java语言层面上，创建对象（例如克隆，反序列化）通常仅仅是通过一个new关键字而已，而在虚拟机中对象的创建是怎么样的过程呢？

### 1. 对象的创建

当虚拟机遇到一条new指令时，首先将去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那么就必须要先执行相应的类的加载过程。

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可确定，为对象分配空间的任务等于把一块确定大小的内存从Java堆中划分出来。**假设Java堆中的内存是绝对规整的，已经使用的内存放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那么分配内存就是把指针从空闲一端移动对象大小的距离到使用一端，这种分配方式成为“指针碰撞”（bump the pointer）**。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存交错存在，那么就没有办法使用指针碰撞的方式来分配内存，虚拟机需要维护一个列表来记录哪些内存是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种方式称为“空闲列表”。

除了如何划分空间外，还有一个需要考虑的问题是：对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向位的位置，在并发情况下也不是线程安全的。解决这个问题的方案有两个：

1. 对分配内存空间的动作进行同步处理
2. 把内存分配的动作按照线程划分在不同的空间之中进行

实际上，虚拟机采用CAS（Compare and Swap）配上失败重试的方式保证更新方式的原子性。另一种是把内存的分配动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。