# Name Binding 名称绑定

### Introduce

在编程语言中，名称绑定是一种条目与标识符的关联，条目可能是数据（data）或者代码（code）。绑定到一个对象的标识符可以说成是这个对象的引用。机器语言没有内部构建的标识符，但对于程序员来说，命名的对象绑定作为一种服务和强调，是通过编程语言来实现的，换句话说，绑定与机器指令无关，是以编程语言为基础实现的。绑定与作用域（scoping）链接紧密，也就是说作用域决定了名称可以绑定到哪些内存空间上的哪些对象上，且是一条可执行的路径上。

在上下文环境中，使用一个标识符`id`。当前上下文环境为`id`建立了一个绑定，称作绑定事件，在所有的事件中（如表达式，分配，子程序调用），一个标识符表示了它所绑定的内容；这种情况成为应用事件。


### Binding time 
在程序运行之前完成的名称绑定，叫做**静态**绑定，或**早期**绑定，在程序运行过程中完成的绑定，叫做**动态**绑定，同样叫做晚期绑定，或者虚绑定。

一个静态绑定的例子是直接调用C的函数：通过标识符引用的函数不会在运行时发生改变。动态绑定的例子是动态分发。（动态分发：在编程语言中，动态分发是一个选择的过程，来选择一个多态操作的实现，好在运行时去调用它。这是面向对象语言和系统中，最重要的内容和特色。）正如C++中的虚函数调用一样。在程序运行前，一个多态的对象的具体类型是不知道的，可执行的函数是动态绑定的。请看如下的Java代码：
```Java
public void foo(java.util.List<String> list) {
    list.add("bar");
}
```

`List`是一个接口，所以`list`一定引用到了他的一个子类型上去。可能是一个`LinkedList`的引用，一个`ArrayList`的引用，或者一些其他`List`的子类型，但是直到`add`方法被调用前，这个引用的具体类型是无法知道。

### Rebinding and mutation
重绑定不应该与可变的（mutation）混淆了，**重绑定是一个引用的标识符发生了变化**，`mutation`是**被引用的值发生了变化**。考虑如下的代码：
```Java
LinkedList<String> list;
list = new LinkedList<>();
list.add("foo");
list = null;
```
`list`最开始没有引用任何的内容，它是为初始化的。然后它被绑定到一个引用类型的对象上，之后链表被引用的值发生了变化，增加了一个字符串到列表中，最后链表用重新绑定到一个`null`对象上。